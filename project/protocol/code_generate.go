package main

import (
	"errors"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

// ProtocolInfo 包含协议名称和ID
type ProtocolInfo struct {
	Name string
	ID   string
	Req  string
	Res  string
}

// GeneratedFunction 生成的处理函数代码
type GeneratedFunction struct {
	FuncName string
	Content  string
}

func main() {
	// 1. 扫描proto目录，收集ProtocolId枚举定义
	wd, err := os.Getwd()
	if err != nil {
		log.Fatal(err)
	}
	protoDir := filepath.Join(wd, "/protocol/protobuf")
	protocols, err := scanProtocols(protoDir)
	if err != nil {
		log.Fatal(err)
	}

	// 2. 生成对应的处理函数代码
	generatedFunctions := generateHandlerFunctions(protocols)

	// 3. 将生成的代码写入文件
	outputDir := filepath.Join("protocol", "generate")
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		log.Fatal(err)
	}

	outputFile := filepath.Join(outputDir, "handlers.go")
	if err := writeGeneratedCode(generatedFunctions, outputFile); err != nil {
		log.Fatal(err)
	}

	fmt.Println("Successfully generated protocol handlers in", outputFile)
}

// scanProtocols 扫描proto目录查找ProtocolId枚举
func scanProtocols(dir string) ([]ProtocolInfo, error) {
	var protocols []ProtocolInfo

	err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if !info.IsDir() && strings.HasSuffix(info.Name(), ".proto") {
			content, err := os.ReadFile(path)
			if err != nil {
				return err
			}

			// 查找ProtocolId枚举
			enumRegex := regexp.MustCompile(`enum\s+ProtocolId\s*\{([^}]+)\}`)
			matches := enumRegex.FindStringSubmatch(string(content))
			if len(matches) < 0 {
				return errors.New("cannot find ProtocolId enum")
			}

			// 匹配enum中的各个项
			itemRegex := regexp.MustCompile(`(\w+)\s*=\s*(\d+);\s*//\s*req:\s*(\w+),\s*res:\s*(\w+)`)
			enumItems := itemRegex.FindAllStringSubmatch(matches[1], -1)

			for _, item := range enumItems {
				if len(item) < 5 { // 现在需要5个匹配项：完整匹配+4个捕获组
					continue
				}

				protocolName := item[1] // 例如 "Login"
				protocolID := item[2]   // 例如 "1"
				reqType := item[3]      // 例如 "LoginC2S"
				resType := item[4]      // 例如 "LoginS2C"

				// 跳过Null协议
				if protocolName == "Null" {
					continue
				}
				protocols = append(protocols, ProtocolInfo{
					Name: protocolName,
					ID:   protocolID,
					Req:  reqType,
					Res:  resType,
				})
			}
		}
		return nil
	})
	return protocols, err
}

// generateHandlerFunctions 为每个协议生成处理函数
func generateHandlerFunctions(protocols []ProtocolInfo) []GeneratedFunction {
	var functions []GeneratedFunction

	for _, protocol := range protocols {
		funcName := "Handle" + protocol.Name
		content := fmt.Sprintf(`
func %s(body []byte) error {
	// TODO: implement %s handler
	return nil
}
`, funcName, funcName)

		functions = append(functions, GeneratedFunction{
			FuncName: funcName,
			Content:  content,
		})
	}
	return functions
}

// writeGeneratedCode 将生成的代码写入文件
func writeGeneratedCode(functions []GeneratedFunction, outputPath string) error {
	var builder strings.Builder

	// 写入文件头
	builder.WriteString(`
// Code generated by protocol/code_generate.go; DO NOT EDIT.

package protocol

`)
	builder.WriteString("type CSHandler struct {")
	builder.WriteString("\n")
	for _, fn := range functions {
		builder.WriteString(fmt.Sprintf("\t%s func(body []byte) error", fn.FuncName))
		builder.WriteString("\n")
	}
	builder.WriteString("}")
	builder.WriteString("\n")

	return os.WriteFile(outputPath, []byte(builder.String()), 0644)
}
